<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/ui/screens/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/ui/screens/SettingsScreen.kt" />
              <option name="originalContent" value="package com.example.anima.ui.screens&#10;&#10;import android.Manifest&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.app.TimePickerDialog&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import androidx.compose.ui.unit.dp&#10;import com.example.anima.util.AlarmHelper&#10;import com.example.anima.util.NotificationHelper&#10;import com.example.anima.util.SecurePrefs&#10;import android.provider.Settings&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    val context = LocalContext.current&#10;    val prefs = SecurePrefs(context)&#10;&#10;    var reminderEnabled by remember { mutableStateOf(prefs.isReminderEnabled()) }&#10;    var hour by remember { mutableStateOf(prefs.getReminderHour()) }&#10;    var minute by remember { mutableStateOf(prefs.getReminderMinute()) }&#10;    var message by remember { mutableStateOf(TextFieldValue(prefs.getReminderMessage())) }&#10;    var themeMode by remember { mutableStateOf(prefs.getThemeMode()) }&#10;    var newPin by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPinConfirm by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // register permission launcher after state so callback can access current values&#10;    val notificationLauncher = rememberLauncherForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { granted: Boolean -&gt;&#10;        if (!granted) {&#10;            Toast.makeText(context, &quot;Permiso de notificaciones denegado. No se programará el recordatorio.&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            // If the user granted permission and the user currently wants reminders enabled,&#10;            // schedule the reminder now.&#10;            if (reminderEnabled) {&#10;                try {&#10;                    AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                    Toast.makeText(context, &quot;Recordatorio programado&quot;, Toast.LENGTH_SHORT).show()&#10;                    // Send a test notification immediately so the user can confirm it works&#10;                    try {&#10;                        NotificationHelper.sendTestNotification(context, message.text)&#10;                    } catch (t: Throwable) {&#10;                        Log.e(&quot;SettingsScreen&quot;, &quot;Failed to send test notification&quot;, t)&#10;                    }&#10;                } catch (t: Throwable) {&#10;                    Log.e(&quot;SettingsScreen&quot;, &quot;Error scheduling reminder after permission grant&quot;, t)&#10;                    Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.Start&#10;    ) {&#10;        // Show last-fired timestamp for diagnostics&#10;        val prefsForUi = remember { SecurePrefs(context) }&#10;        var lastFired by remember { mutableStateOf(prefsForUi.getLastReminderFired()) }&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;Último recordatorio:&quot;)&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            val lastFiredText = if (lastFired == 0L) &quot;Nunca&quot; else java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(java.util.Date(lastFired))&#10;            Text(lastFiredText)&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Button(onClick = { lastFired = prefsForUi.getLastReminderFired() }) { Text(&quot;Refrescar&quot;) }&#10;        }&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        Text(&quot;Recordatorio&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;Activar&quot;)&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Switch(checked = reminderEnabled, onCheckedChange = { reminderEnabled = it })&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            // show TimePicker&#10;            val tp = TimePickerDialog(context, { _, h, m -&gt;&#10;                hour = h&#10;                minute = m&#10;            }, hour, minute, true)&#10;            tp.show()&#10;        }) {&#10;            Text(text = &quot;Hora: %02d:%02d&quot;.format(hour, minute))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(&#10;            value = message,&#10;            onValueChange = { message = it },&#10;            label = { Text(&quot;Mensaje del recordatorio&quot;) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Button(onClick = {&#10;            try {&#10;                prefs.setReminderEnabled(reminderEnabled)&#10;                prefs.setReminderHour(hour)&#10;                prefs.setReminderMinute(minute)&#10;                prefs.setReminderMessage(message.text)&#10;&#10;                // On Android 13+ request POST_NOTIFICATIONS permission before scheduling&#10;                if (reminderEnabled) {&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                        val granted = context.checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED&#10;                        if (!granted) {&#10;                            notificationLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                            // user will decide; don't schedule until permission result or they re-save&#10;                            Toast.makeText(context, &quot;Solicitando permiso de notificaciones... Vuelva a guardar para programar si concede permiso.&quot;, Toast.LENGTH_LONG).show()&#10;                        } else {&#10;                            try {&#10;                                AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                                // send a test notification to confirm&#10;                                try {&#10;                                    NotificationHelper.sendTestNotification(context, message.text)&#10;                                } catch (t: Throwable) {&#10;                                    Log.e(&quot;SettingsScreen&quot;, &quot;Failed to send test notification&quot;, t)&#10;                                }&#10;                            } catch (t: Throwable) {&#10;                                Log.e(&quot;SettingsScreen&quot;, &quot;Error scheduling reminder&quot;, t)&#10;                                Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                            }&#10;                        }&#10;                    } else {&#10;                        try {&#10;                            AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                            // send a test notification to confirm&#10;                            try {&#10;                                NotificationHelper.sendTestNotification(context, message.text)&#10;                            } catch (t: Throwable) {&#10;                                Log.e(&quot;SettingsScreen&quot;, &quot;Failed to send test notification&quot;, t)&#10;                            }&#10;                        } catch (t: Throwable) {&#10;                            Log.e(&quot;SettingsScreen&quot;, &quot;Error scheduling reminder&quot;, t)&#10;                            Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                        }&#10;                    }&#10;                } else {&#10;                    try {&#10;                        AlarmHelper.cancelReminder(context)&#10;                    } catch (t: Throwable) {&#10;                        Log.e(&quot;SettingsScreen&quot;, &quot;Error cancelling reminder&quot;, t)&#10;                        Toast.makeText(context, &quot;No se pudo cancelar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;&#10;                Toast.makeText(context, &quot;Recordatorio configurado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;            } catch (e: Throwable) {&#10;                Log.e(&quot;SettingsScreen&quot;, &quot;Unhandled error saving reminder&quot;, e)&#10;                Toast.makeText(context, &quot;Error al guardar recordatorio: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }) {&#10;            Text(&quot;Guardar recordatorio&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            try {&#10;                // quick test notification to validate permissions and channel&#10;                NotificationHelper.sendTestNotification(context, message.text)&#10;                Toast.makeText(context, &quot;Notificación de prueba enviada&quot;, Toast.LENGTH_SHORT).show()&#10;            } catch (t: Throwable) {&#10;                Log.e(&quot;SettingsScreen&quot;, &quot;Failed to send test notification on demand&quot;, t)&#10;                Toast.makeText(context, &quot;No se pudo enviar notificación de prueba: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }) {&#10;            Text(&quot;Enviar notificación de prueba&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            try {&#10;                val now = System.currentTimeMillis()&#10;                val trigger = now + 10_000L // 10 seconds from now&#10;                val scheduled = AlarmHelper.scheduleAtMillis(context, trigger, message.text)&#10;                val timeStr = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(java.util.Date(trigger))&#10;                if (scheduled) {&#10;                    Toast.makeText(context, &quot;Alarma de prueba programada para $timeStr&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    // fallback: try scheduling directly without FLAG_IMMUTABLE&#10;                    try {&#10;                        val alarmManager = context.getSystemService(android.content.Context.ALARM_SERVICE) as AlarmManager&#10;                        val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply { putExtra(&quot;msg&quot;, message.text) }&#10;                        val pending = PendingIntent.getBroadcast(context, 9999, intent, PendingIntent.FLAG_UPDATE_CURRENT)&#10;                        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, trigger, pending)&#10;                        Toast.makeText(context, &quot;Alarma de prueba programada (fallback) para $timeStr&quot;, Toast.LENGTH_SHORT).show()&#10;                    } catch (ex: Throwable) {&#10;                        Log.e(&quot;SettingsScreen&quot;, &quot;Fallback scheduling failed&quot;, ex)&#10;                        // If scheduling failed, check if exact alarms are allowed (Android 12+)&#10;                        try {&#10;                            val alarmManager = context.getSystemService(android.content.Context.ALARM_SERVICE) as AlarmManager&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                                val canSchedule = alarmManager.canScheduleExactAlarms()&#10;                                if (!canSchedule) {&#10;                                    Toast.makeText(context, &quot;La app no puede programar alarmas exactas. Abriendo ajustes...&quot;, Toast.LENGTH_LONG).show()&#10;                                    try {&#10;                                        val intentSettings = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;                                        context.startActivity(intentSettings)&#10;                                    } catch (ie: Throwable) {&#10;                                        Log.e(&quot;SettingsScreen&quot;, &quot;Failed to open exact alarms settings&quot;, ie)&#10;                                        Toast.makeText(context, &quot;No se pudo abrir ajustes de alarmas exactas: ${ie.message}&quot;, Toast.LENGTH_LONG).show()&#10;                                    }&#10;                                    return@Button&#10;                                }&#10;                            }&#10;                        } catch (ie: Throwable) {&#10;                            Log.e(&quot;SettingsScreen&quot;, &quot;Error while checking exact alarms capability&quot;, ie)&#10;                        }&#10;&#10;                        Toast.makeText(context, &quot;No se pudo programar la alarma de prueba: ${ex.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            } catch (t: Throwable) {&#10;                Log.e(&quot;SettingsScreen&quot;, &quot;Failed to schedule quick test alarm&quot;, t)&#10;                Toast.makeText(context, &quot;Error al programar alarma de prueba: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }) {&#10;            Text(&quot;Programar prueba en 10s&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        HorizontalDivider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Seguridad&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPin, onValueChange = { newPin = it }, label = { Text(&quot;Nuevo PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPinConfirm, onValueChange = { newPinConfirm = it }, label = { Text(&quot;Confirmar PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            if (newPin.isBlank()) { Toast.makeText(context, &quot;PIN no puede estar vacío&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            if (newPin != newPinConfirm) { Toast.makeText(context, &quot;PIN y confirmación no coinciden&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            prefs.setPin(newPin)&#10;            Toast.makeText(context, &quot;PIN guardado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;            newPin = &quot;&quot;&#10;            newPinConfirm = &quot;&quot;&#10;        }) {&#10;            Text(&quot;Establecer PIN&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        HorizontalDivider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Apariencia&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row {&#10;            Button(onClick = { themeMode = 0 }) { Text(&quot;Seguir sistema&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 1 }) { Text(&quot;Claro&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 2 }) { Text(&quot;Oscuro&quot;) }&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            prefs.setThemeMode(themeMode)&#10;            Toast.makeText(context, &quot;Modo oscuro activado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;        }) {&#10;            Text(&quot;Guardar apariencia&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.anima.ui.screens&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.widget.Toast&#10;import android.app.TimePickerDialog&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import androidx.compose.ui.unit.dp&#10;import com.example.anima.util.AlarmHelper&#10;import com.example.anima.util.SecurePrefs&#10;import android.provider.Settings&#10;import androidx.core.net.toUri&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    val context = LocalContext.current&#10;    val prefs = SecurePrefs(context)&#10;&#10;    var reminderEnabled by remember { mutableStateOf(prefs.isReminderEnabled()) }&#10;    var hour by remember { mutableStateOf(prefs.getReminderHour()) }&#10;    var minute by remember { mutableStateOf(prefs.getReminderMinute()) }&#10;    var message by remember { mutableStateOf(TextFieldValue(prefs.getReminderMessage())) }&#10;    var themeMode by remember { mutableStateOf(prefs.getThemeMode()) }&#10;    var newPin by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPinConfirm by remember { mutableStateOf(&quot;&quot;) }&#10;    // UI state to show explanatory dialogs for permissions/settings&#10;    var showNotificationPermissionDialog by remember { mutableStateOf(false) }&#10;    var showExactAlarmsDialog by remember { mutableStateOf(false) }&#10;    // helper to open notification settings for older devices&#10;    val openNotificationSettings = {&#10;        try {&#10;            val intent = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS).apply {&#10;                    putExtra(Settings.EXTRA_APP_PACKAGE, context.packageName)&#10;                }&#10;            } else {&#10;                Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;                    data = &quot;package:${context.packageName}&quot;.toUri()&#10;                }&#10;            }&#10;            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;            context.startActivity(intent)&#10;        } catch (e: Throwable) {&#10;            // silent fail: avoid debug logs in production UI&#10;            Toast.makeText(context, &quot;No se pudo abrir ajustes de notificaciones: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    // register permission launcher after state so callback can access current values&#10;    val notificationLauncher = rememberLauncherForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { granted: Boolean -&gt;&#10;        if (!granted) {&#10;            Toast.makeText(context, &quot;Permiso de notificaciones denegado. No se programará el recordatorio.&quot;, Toast.LENGTH_SHORT).show()&#10;        } else {&#10;            // If the user granted permission and the user currently wants reminders enabled,&#10;            // schedule the reminder now.&#10;            if (reminderEnabled) {&#10;                try {&#10;                    AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                    Toast.makeText(context, &quot;Recordatorio programado&quot;, Toast.LENGTH_SHORT).show()&#10;                } catch (t: Throwable) {&#10;                    // ignore detailed debug log&#10;                    Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.Start&#10;    ) {&#10;        // diagnostics removed for production&#10;        Text(&quot;Recordatorio&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;Activar&quot;)&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Switch(checked = reminderEnabled, onCheckedChange = { reminderEnabled = it })&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            // show TimePicker&#10;            val tp = TimePickerDialog(context, { _, h, m -&gt;&#10;                hour = h&#10;                minute = m&#10;            }, hour, minute, true)&#10;            tp.show()&#10;        }) {&#10;            Text(text = &quot;Hora: %02d:%02d&quot;.format(hour, minute))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(&#10;            value = message,&#10;            onValueChange = { message = it },&#10;            label = { Text(&quot;Mensaje del recordatorio&quot;) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Button(onClick = {&#10;            try {&#10;                prefs.setReminderEnabled(reminderEnabled)&#10;                prefs.setReminderHour(hour)&#10;                prefs.setReminderMinute(minute)&#10;                prefs.setReminderMessage(message.text)&#10;&#10;                // On Android 13+ request POST_NOTIFICATIONS permission before scheduling&#10;                if (reminderEnabled) {&#10;                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                        val granted = context.checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED&#10;                        if (!granted) {&#10;                            // show a dialog explaining why we need notification permission; launcher will be invoked if user accepts&#10;                            showNotificationPermissionDialog = true&#10;                            // user will decide in the dialog; don't schedule until permission result or they re-save&#10;                        } else {&#10;                            try {&#10;                                AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                                Toast.makeText(context, &quot;Recordatorio programado&quot;, Toast.LENGTH_SHORT).show()&#10;                                // (test notification removed to avoid instant notification on save)&#10;                            } catch (t: Throwable) {&#10;                                // ignore detailed debug log&#10;                                Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                            }&#10;                        }&#10;                    } else {&#10;                        try {&#10;                            AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                            Toast.makeText(context, &quot;Recordatorio programado&quot;, Toast.LENGTH_SHORT).show()&#10;                            // (test notification removed to avoid instant notification on save)&#10;                        } catch (t: Throwable) {&#10;                            // ignore detailed debug log&#10;                            Toast.makeText(context, &quot;No se pudo programar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                        }&#10;                    }&#10;                } else {&#10;                    try {&#10;                        AlarmHelper.cancelReminder(context)&#10;                    } catch (t: Throwable) {&#10;                        // ignore detailed debug log&#10;                        Toast.makeText(context, &quot;No se pudo cancelar el recordatorio: ${t.message}&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;&#10;                Toast.makeText(context, &quot;Recordatorio configurado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;            } catch (e: Throwable) {&#10;                Toast.makeText(context, &quot;Error al guardar recordatorio: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }) {&#10;            Text(&quot;Guardar recordatorio&quot;)&#10;        }&#10;&#10;        // Notification permission explanatory dialog&#10;        if (showNotificationPermissionDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = { showNotificationPermissionDialog = false },&#10;                title = { Text(&quot;Permisos para recordatorios y notificaciones&quot;) },&#10;                text = { Text(&quot;La aplicación necesita permiso para mostrar notificaciones (para recordatorios) y, según la versión de Android, permiso para programar alarmas exactas. ¿Desea conceder estos permisos ahora?&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        showNotificationPermissionDialog = false&#10;                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            notificationLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                        } else {&#10;                            openNotificationSettings()&#10;                        }&#10;                    }) { Text(&quot;Abrir&quot;) }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { showNotificationPermissionDialog = false }) { Text(&quot;Cancelar&quot;) }&#10;                }&#10;            )&#10;        }&#10;&#10;        // Exact alarms explanatory dialog&#10;        if (showExactAlarmsDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = { showExactAlarmsDialog = false },&#10;                title = { Text(&quot;Permiso para alarmas (recordatorios exactos)&quot;) },&#10;                text = { Text(&quot;La aplicación necesita permiso para programar alarmas exactas para que los recordatorios se disparen a la hora correcta. ¿Desea abrir los ajustes para permitirlo?&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        showExactAlarmsDialog = false&#10;                        try {&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                                val intentSettings = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }&#10;                                context.startActivity(intentSettings)&#10;                            } else {&#10;                                // fallback: open app details settings so user can inspect permissions&#10;                                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;                                    data = &quot;package:${context.packageName}&quot;.toUri()&#10;                                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;                                }&#10;                                context.startActivity(intent)&#10;                            }&#10;                         } catch (ex: Throwable) {&#10;                             // ignore detailed debug log&#10;                             Toast.makeText(context, &quot;No se pudo abrir ajustes de alarmas exactas: ${ex.message}&quot;, Toast.LENGTH_LONG).show()&#10;                         }&#10;                    }) { Text(&quot;Abrir ajustes&quot;) }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { showExactAlarmsDialog = false }) { Text(&quot;Cancelar&quot;) }&#10;                }&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        HorizontalDivider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Seguridad&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPin, onValueChange = { newPin = it }, label = { Text(&quot;Nuevo PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPinConfirm, onValueChange = { newPinConfirm = it }, label = { Text(&quot;Confirmar PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            if (newPin.isBlank()) { Toast.makeText(context, &quot;PIN no puede estar vacío&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            if (newPin != newPinConfirm) { Toast.makeText(context, &quot;PIN y confirmación no coinciden&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            prefs.setPin(newPin)&#10;            Toast.makeText(context, &quot;PIN guardado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;            newPin = &quot;&quot;&#10;            newPinConfirm = &quot;&quot;&#10;        }) {&#10;            Text(&quot;Establecer PIN&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        HorizontalDivider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Apariencia&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row {&#10;            Button(onClick = { themeMode = 0 }) { Text(&quot;Seguir sistema&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 1 }) { Text(&quot;Claro&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 2 }) { Text(&quot;Oscuro&quot;) }&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            prefs.setThemeMode(themeMode)&#10;            Toast.makeText(context, &quot;Modo oscuro activado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;        }) {&#10;            Text(&quot;Guardar apariencia&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt" />
              <option name="originalContent" value="package com.example.anima.util&#10;&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.util.Calendar&#10;&#10;object AlarmHelper {&#10;    private const val REQUEST_CODE_REMINDER = 1001&#10;    private const val REQUEST_CODE_SHOW = 1002&#10;    private const val REQUEST_CODE_TEST = 1003&#10;&#10;    fun scheduleDailyReminder(context: Context, hour: Int, minute: Int, message: String) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val trigger = computeNextTriggerCalendar(hour, minute)&#10;&#10;            // debug log scheduled time&#10;            val scheduledStr = &quot;%04d-%02d-%02d %02d:%02d&quot;.format(&#10;                trigger.get(Calendar.YEAR),&#10;                trigger.get(Calendar.MONTH) + 1,&#10;                trigger.get(Calendar.DAY_OF_MONTH),&#10;                trigger.get(Calendar.HOUR_OF_DAY),&#10;                trigger.get(Calendar.MINUTE)&#10;            )&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling daily reminder for: $scheduledStr (epoch=${trigger.timeInMillis})&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                // Try to use setAlarmClock for more reliable exact delivery&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(trigger.timeInMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed, falling back to setExactAndAllowWhileIdle&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                // fallback&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    trigger.timeInMillis,&#10;                    pending&#10;                )&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            // verify the pending intent exists now&#10;            val exists = isReminderScheduled(context)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Reminder PendingIntent exists after schedule: $exists&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule daily reminder&quot;, t)&#10;            // swallow to avoid crashing UI flows&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule an alarm at a specific epoch millisecond time for quick testing.&#10;     * Returns true if scheduled without throwing.&#10;     */&#10;    fun scheduleAtMillis(context: Context, triggerMillis: Long, message: String): Boolean {&#10;        return try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_TEST,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val scheduledStr = java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(java.util.Date(triggerMillis))&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling test alarm for: $scheduledStr (epoch=$triggerMillis)&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(triggerMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed for test alarm, falling back&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerMillis, pending)&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule test alarm&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun cancelReminder(context: Context) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            alarmManager.cancel(pending)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Cancelled reminder (PendingIntent canceled)&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to cancel reminder&quot;, t)&#10;        }&#10;    }&#10;&#10;    fun isReminderScheduled(context: Context): Boolean {&#10;        return try {&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            pending != null&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Error checking reminder pending intent&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Compute and return the next trigger time in epoch millis for the given hour/minute&#10;    fun computeNextTriggerMillis(hour: Int, minute: Int): Long {&#10;        val cal = computeNextTriggerCalendar(hour, minute)&#10;        return cal.timeInMillis&#10;    }&#10;&#10;    private fun computeNextTriggerCalendar(hour: Int, minute: Int): Calendar {&#10;        val now = Calendar.getInstance()&#10;        val trigger = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, hour)&#10;            set(Calendar.MINUTE, minute)&#10;            set(Calendar.SECOND, 0)&#10;            set(Calendar.MILLISECOND, 0)&#10;            if (before(now)) {&#10;                add(Calendar.DAY_OF_YEAR, 1)&#10;            }&#10;        }&#10;        return trigger&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.util.Calendar&#10;&#10;object AlarmHelper {&#10;    private const val REQUEST_CODE_REMINDER = 1001&#10;    private const val REQUEST_CODE_SHOW = 1002&#10;    private const val REQUEST_CODE_TEST = 1003&#10;&#10;    fun scheduleDailyReminder(context: Context, hour: Int, minute: Int, message: String) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val trigger = computeNextTriggerCalendar(hour, minute)&#10;&#10;            // debug log scheduled time&#10;            val scheduledStr = &quot;%04d-%02d-%02d %02d:%02d&quot;.format(&#10;                trigger.get(Calendar.YEAR),&#10;                trigger.get(Calendar.MONTH) + 1,&#10;                trigger.get(Calendar.DAY_OF_MONTH),&#10;                trigger.get(Calendar.HOUR_OF_DAY),&#10;                trigger.get(Calendar.MINUTE)&#10;            )&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling daily reminder for: $scheduledStr (epoch=${trigger.timeInMillis})&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                // Try to use setAlarmClock for more reliable exact delivery&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(trigger.timeInMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed, falling back to setExactAndAllowWhileIdle&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                // fallback&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    trigger.timeInMillis,&#10;                    pending&#10;                )&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            // verify the pending intent exists now&#10;            val exists = isReminderScheduled(context)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Reminder PendingIntent exists after schedule: $exists&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule daily reminder&quot;, t)&#10;            // swallow to avoid crashing UI flows&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule an alarm at a specific epoch millisecond time for quick testing.&#10;     * Returns true if scheduled without throwing.&#10;     */&#10;    fun scheduleAtMillis(context: Context, triggerMillis: Long, message: String): Boolean {&#10;        return try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_TEST,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val scheduledStr = java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(java.util.Date(triggerMillis))&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling test alarm for: $scheduledStr (epoch=$triggerMillis)&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(triggerMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed for test alarm, falling back&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerMillis, pending)&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule test alarm&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun cancelReminder(context: Context) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            alarmManager.cancel(pending)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Cancelled reminder (PendingIntent canceled)&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to cancel reminder&quot;, t)&#10;        }&#10;    }&#10;&#10;    fun isReminderScheduled(context: Context): Boolean {&#10;        return try {&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            pending != null&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Error checking reminder pending intent&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Compute and return the next trigger time in epoch millis for the given hour/minute&#10;    fun computeNextTriggerMillis(hour: Int, minute: Int): Long {&#10;        val cal = computeNextTriggerCalendar(hour, minute)&#10;        return cal.timeInMillis&#10;    }&#10;&#10;    private fun computeNextTriggerCalendar(hour: Int, minute: Int): Calendar {&#10;        val now = Calendar.getInstance()&#10;        val trigger = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, hour)&#10;            set(Calendar.MINUTE, minute)&#10;            set(Calendar.SECOND, 0)&#10;            set(Calendar.MILLISECOND, 0)&#10;            // If trigger is not strictly after 'now' (equal or before), schedule for next day&#10;            if (!after(now)) {&#10;                add(Calendar.DAY_OF_YEAR, 1)&#10;            }&#10;        }&#10;        return trigger&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import com.example.anima.util.SecurePrefs&#10;import com.example.anima.util.AlarmHelper&#10;&#10;class BootReceiver : BroadcastReceiver() {&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        val action = intent?.action&#10;        if (action != Intent.ACTION_BOOT_COMPLETED &amp;&amp; action != Intent.ACTION_LOCKED_BOOT_COMPLETED) return&#10;        try {&#10;            val prefs = SecurePrefs(context)&#10;            if (prefs.isReminderEnabled()) {&#10;                AlarmHelper.scheduleDailyReminder(context, prefs.getReminderHour(), prefs.getReminderMinute(), prefs.getReminderMessage())&#10;            }&#10;        } catch (t: Throwable) {&#10;            // ignore errors on boot handling&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>