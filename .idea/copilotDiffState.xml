<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.anima&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.anima&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;    // Room (explicit coordinates)&#10;    implementation(&quot;androidx.room:room-runtime:2.8.3&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.8.3&quot;)&#10;    kapt(&quot;androidx.room:room-compiler:2.8.3&quot;)&#10;&#10;    // Lifecycle ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.9.4&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.0&quot;)&#10;&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.anima&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.anima&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;    // Room (explicit coordinates)&#10;    implementation(&quot;androidx.room:room-runtime:2.8.3&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.8.3&quot;)&#10;    kapt(&quot;androidx.room:room-compiler:2.8.3&quot;)&#10;&#10;    // Lifecycle ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.9.4&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.0&quot;)&#10;&#10;    // Biometric authentication&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;&#10;    // Encrypted SharedPreferences for secure PIN storage&#10;    implementation(&quot;androidx.security:security-crypto:1.0.0&quot;)&#10;&#10;    // Optional: WorkManager (in case we later want it instead of AlarmManager)&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.8.1&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;!-- Permission to receive boot completed so we can reschedule alarms --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.LockActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot; /&gt;&#10;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.NotificationReceiver&quot; android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.BootReceiver&quot; android:exported=&quot;true&quot; android:permission=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/MainActivity.kt" />
              <option name="originalContent" value="package com.example.anima&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.anima.ui.theme.AnimaTheme&#10;import androidx.compose.material3.Button&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.example.anima.ui.screens.DailyEntryScreen&#10;import com.example.anima.ui.screens.CalendarScreen&#10;import com.example.anima.viewmodel.DailyViewModel&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            AnimaTheme {&#10;                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                    AppContent(Modifier.padding(innerPadding))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AppContent(modifier: Modifier = Modifier) {&#10;    val navController = rememberNavController()&#10;    val vm: DailyViewModel = viewModel()&#10;&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        // simple top row to switch screens&#10;        Row(modifier = Modifier&#10;            .padding(8.dp)) {&#10;            Button(onClick = { navController.navigate(&quot;daily&quot;) }) {&#10;                Text(&quot;Diario&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { navController.navigate(&quot;calendar&quot;) }) {&#10;                Text(&quot;Calendario&quot;)&#10;            }&#10;        }&#10;&#10;        NavHost(navController = navController, startDestination = &quot;daily&quot;) {&#10;            composable(&quot;daily&quot;) {&#10;                DailyEntryScreen(viewModel = vm)&#10;            }&#10;            composable(&quot;calendar&quot;) {&#10;                CalendarScreen(viewModel = vm)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Greeting(name: String, modifier: Modifier = Modifier) {&#10;    Text(&#10;        text = &quot;Hello $name!&quot;,&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    AnimaTheme {&#10;        Greeting(&quot;Android&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.anima&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.anima.ui.theme.AnimaTheme&#10;import androidx.compose.material3.Button&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import com.example.anima.ui.screens.DailyEntryScreen&#10;import com.example.anima.ui.screens.CalendarScreen&#10;import com.example.anima.ui.screens.SettingsScreen&#10;import com.example.anima.viewmodel.DailyViewModel&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            AnimaTheme {&#10;                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                    AppContent(Modifier.padding(innerPadding))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AppContent(modifier: Modifier = Modifier) {&#10;    val navController = rememberNavController()&#10;    val vm: DailyViewModel = viewModel()&#10;&#10;    Scaffold(modifier = modifier) { padding -&gt;&#10;        // simple top row to switch screens&#10;        Row(modifier = Modifier&#10;            .padding(8.dp)) {&#10;            Button(onClick = { navController.navigate(&quot;daily&quot;) }) {&#10;                Text(&quot;Diario&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { navController.navigate(&quot;calendar&quot;) }) {&#10;                Text(&quot;Calendario&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { navController.navigate(&quot;settings&quot;) }) {&#10;                Text(&quot;Ajustes&quot;)&#10;            }&#10;        }&#10;&#10;        NavHost(navController = navController, startDestination = &quot;daily&quot;) {&#10;            composable(&quot;daily&quot;) {&#10;                DailyEntryScreen(viewModel = vm)&#10;            }&#10;            composable(&quot;calendar&quot;) {&#10;                CalendarScreen(viewModel = vm)&#10;            }&#10;            composable(&quot;settings&quot;) {&#10;                SettingsScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Greeting(name: String, modifier: Modifier = Modifier) {&#10;    Text(&#10;        text = &quot;Hello $name!&quot;,&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    AnimaTheme {&#10;        Greeting(&quot;Android&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/ui/screens/SettingsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/ui/screens/SettingsScreen.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package com.example.anima.ui.screens&#10;&#10;import android.Manifest&#10;import android.app.TimePickerDialog&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import androidx.compose.ui.unit.dp&#10;import com.example.anima.util.AlarmHelper&#10;import com.example.anima.util.SecurePrefs&#10;import java.util.Calendar&#10;&#10;@Composable&#10;fun SettingsScreen() {&#10;    val context = LocalContext.current&#10;    val prefs = SecurePrefs(context)&#10;&#10;    val notificationLauncher = rememberLauncherForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { granted: Boolean -&gt;&#10;        if (!granted) {&#10;            Toast.makeText(context, &quot;Permiso de notificaciones denegado. No se programará el recordatorio.&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    var reminderEnabled by remember { mutableStateOf(prefs.isReminderEnabled()) }&#10;    var hour by remember { mutableStateOf(prefs.getReminderHour()) }&#10;    var minute by remember { mutableStateOf(prefs.getReminderMinute()) }&#10;    var message by remember { mutableStateOf(TextFieldValue(prefs.getReminderMessage())) }&#10;    var themeMode by remember { mutableStateOf(prefs.getThemeMode()) }&#10;    var newPin by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPinConfirm by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.Start&#10;    ) {&#10;        Text(&quot;Recordatorio&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row(verticalAlignment = Alignment.CenterVertically) {&#10;            Text(&quot;Activar&quot;)&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Switch(checked = reminderEnabled, onCheckedChange = { reminderEnabled = it })&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            // show TimePicker&#10;            val tp = TimePickerDialog(context, { _, h, m -&gt;&#10;                hour = h&#10;                minute = m&#10;            }, hour, minute, true)&#10;            tp.show()&#10;        }) {&#10;            Text(text = &quot;Hora: %02d:%02d&quot;.format(hour, minute))&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(&#10;            value = message,&#10;            onValueChange = { message = it },&#10;            label = { Text(&quot;Mensaje del recordatorio&quot;) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;        Button(onClick = {&#10;            prefs.setReminderEnabled(reminderEnabled)&#10;            prefs.setReminderHour(hour)&#10;            prefs.setReminderMinute(minute)&#10;            prefs.setReminderMessage(message.text)&#10;&#10;            // On Android 13+ request POST_NOTIFICATIONS permission before scheduling&#10;            if (reminderEnabled) {&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                    val granted = context.checkSelfPermission(Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED&#10;                    if (!granted) {&#10;                        notificationLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                        // user will decide; don't schedule until permission result or they re-save&#10;                        Toast.makeText(context, &quot;Solicitando permiso de notificaciones... Vuelva a guardar para programar si concede permiso.&quot;, Toast.LENGTH_LONG).show()&#10;                    } else {&#10;                        AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                    }&#10;                } else {&#10;                    AlarmHelper.scheduleDailyReminder(context, hour, minute, message.text)&#10;                }&#10;            } else {&#10;                AlarmHelper.cancelReminder(context)&#10;            }&#10;&#10;            if (reminderEnabled) {&#10;                // if already scheduled above it was scheduled; otherwise a toast informs the user&#10;            }&#10;            Toast.makeText(context, &quot;Recordatorio configurado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;        }) {&#10;            Text(&quot;Guardar recordatorio&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Divider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Seguridad&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPin, onValueChange = { newPin = it }, label = { Text(&quot;Nuevo PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        OutlinedTextField(value = newPinConfirm, onValueChange = { newPinConfirm = it }, label = { Text(&quot;Confirmar PIN&quot;) }, modifier = Modifier.fillMaxWidth())&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            if (newPin.isBlank()) { Toast.makeText(context, &quot;PIN no puede estar vacío&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            if (newPin != newPinConfirm) { Toast.makeText(context, &quot;PIN y confirmación no coinciden&quot;, Toast.LENGTH_SHORT).show(); return@Button }&#10;            prefs.setPin(newPin)&#10;            Toast.makeText(context, &quot;PIN guardado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;            newPin = &quot;&quot;&#10;            newPinConfirm = &quot;&quot;&#10;        }) {&#10;            Text(&quot;Establecer PIN&quot;)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Divider()&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&quot;Apariencia&quot;, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Row {&#10;            Button(onClick = { themeMode = 0 }) { Text(&quot;Seguir sistema&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 1 }) { Text(&quot;Claro&quot;) }&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Button(onClick = { themeMode = 2 }) { Text(&quot;Oscuro&quot;) }&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(onClick = {&#10;            prefs.setThemeMode(themeMode)&#10;            Toast.makeText(context, &quot;Modo oscuro activado correctamente&quot;, Toast.LENGTH_SHORT).show()&#10;        }) {&#10;            Text(&quot;Guardar apariencia&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import java.util.Calendar&#10;&#10;object AlarmHelper {&#10;    private const val REQUEST_CODE_REMINDER = 1001&#10;&#10;    fun scheduleDailyReminder(context: Context, hour: Int, minute: Int, message: String) {&#10;        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;        val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;            putExtra(&quot;msg&quot;, message)&#10;        }&#10;        val pending = PendingIntent.getBroadcast(&#10;            context,&#10;            REQUEST_CODE_REMINDER,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        val now = Calendar.getInstance()&#10;        val trigger = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, hour)&#10;            set(Calendar.MINUTE, minute)&#10;            set(Calendar.SECOND, 0)&#10;            set(Calendar.MILLISECOND, 0)&#10;            if (before(now)) {&#10;                add(Calendar.DAY_OF_YEAR, 1)&#10;            }&#10;        }&#10;&#10;        // Use exact alarm when possible (compat with Doze)&#10;        alarmManager.setExactAndAllowWhileIdle(&#10;            AlarmManager.RTC_WAKEUP,&#10;            trigger.timeInMillis,&#10;            pending&#10;        )&#10;    }&#10;&#10;    fun cancelReminder(context: Context) {&#10;        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;        val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;        val pending = PendingIntent.getBroadcast(&#10;            context,&#10;            REQUEST_CODE_REMINDER,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;        alarmManager.cancel(pending)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import com.example.anima.util.SecurePrefs&#10;import com.example.anima.util.AlarmHelper&#10;&#10;class BootReceiver : BroadcastReceiver() {&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        val action = intent?.action&#10;        if (action != Intent.ACTION_BOOT_COMPLETED &amp;&amp; action != Intent.ACTION_LOCKED_BOOT_COMPLETED) return&#10;        try {&#10;            val prefs = SecurePrefs(context)&#10;            if (prefs.isReminderEnabled()) {&#10;                AlarmHelper.scheduleDailyReminder(context, prefs.getReminderHour(), prefs.getReminderMinute(), prefs.getReminderMessage())&#10;            }&#10;        } catch (t: Throwable) {&#10;            // ignore errors on boot handling&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationReceiver.kt" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import java.util.concurrent.Executors&#10;&#10;class NotificationReceiver : BroadcastReceiver() {&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;anima_reminder_channel&quot;&#10;    }&#10;&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        val msg = intent?.getStringExtra(&quot;msg&quot;) ?: &quot;¿Cómo te sentís hoy?&quot;&#10;        createChannelIfNeeded(context)&#10;&#10;        val builder = NotificationCompat.Builder(context, CHANNEL_ID)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentTitle(&quot;Anima&quot;)&#10;            .setContentText(msg)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;&#10;        with(NotificationManagerCompat.from(context)) {&#10;            notify(1000, builder.build())&#10;        }&#10;&#10;        // Schedule next day to keep it daily (because we used exact alarm for a single trigger)&#10;        // Read stored hour/minute and reschedule&#10;        Executors.newSingleThreadExecutor().execute {&#10;            try {&#10;                val prefs = SecurePrefs(context)&#10;                if (prefs.isReminderEnabled()) {&#10;                    val h = prefs.getReminderHour()&#10;                    val m = prefs.getReminderMinute()&#10;                    val message = prefs.getReminderMessage()&#10;                    AlarmHelper.scheduleDailyReminder(context, h, m, message)&#10;                }&#10;            } catch (t: Throwable) {&#10;                // ignore&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun createChannelIfNeeded(context: Context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Recordatorios&quot;&#10;            val descriptionText = &quot;Canal para recordatorios diarios&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/SecurePrefs.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/SecurePrefs.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.content.Context&#10;import androidx.security.crypto.EncryptedSharedPreferences&#10;import androidx.security.crypto.MasterKeys&#10;import androidx.core.content.edit&#10;&#10;class SecurePrefs(context: Context) {&#10;    private val masterKeyAlias: String = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)&#10;&#10;    private val prefs = EncryptedSharedPreferences.create(&#10;        &quot;anima_secure_prefs&quot;,&#10;        masterKeyAlias,&#10;        context,&#10;        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,&#10;        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM&#10;    )&#10;&#10;    companion object {&#10;        private const val KEY_THEME_MODE = &quot;theme_mode&quot; // 0=system,1=light,2=dark&#10;        private const val KEY_REMINDER_ENABLED = &quot;reminder_enabled&quot;&#10;        private const val KEY_REMINDER_HOUR = &quot;reminder_hour&quot;&#10;        private const val KEY_REMINDER_MINUTE = &quot;reminder_minute&quot;&#10;        private const val KEY_REMINDER_MSG = &quot;reminder_msg&quot;&#10;        private const val KEY_PIN = &quot;pin&quot;&#10;        private const val KEY_FAILED_ATTEMPTS = &quot;failed_attempts&quot;&#10;        private const val KEY_LOCK_UNTIL = &quot;lock_until&quot;&#10;    }&#10;&#10;    fun getThemeMode(): Int = prefs.getInt(KEY_THEME_MODE, 0)&#10;    fun setThemeMode(mode: Int) = prefs.edit { putInt(KEY_THEME_MODE, mode) }&#10;&#10;    fun isReminderEnabled(): Boolean = prefs.getBoolean(KEY_REMINDER_ENABLED, false)&#10;    fun setReminderEnabled(enabled: Boolean) = prefs.edit { putBoolean(KEY_REMINDER_ENABLED, enabled) }&#10;&#10;    fun getReminderHour(): Int = prefs.getInt(KEY_REMINDER_HOUR, 20)&#10;    fun setReminderHour(h: Int) = prefs.edit { putInt(KEY_REMINDER_HOUR, h) }&#10;&#10;    fun getReminderMinute(): Int = prefs.getInt(KEY_REMINDER_MINUTE, 0)&#10;    fun setReminderMinute(m: Int) = prefs.edit { putInt(KEY_REMINDER_MINUTE, m) }&#10;&#10;    fun getReminderMessage(): String = prefs.getString(KEY_REMINDER_MSG, &quot;¿Cómo te sentís hoy?&quot;) ?: &quot;¿Cómo te sentís hoy?&quot;&#10;    fun setReminderMessage(msg: String) = prefs.edit { putString(KEY_REMINDER_MSG, msg) }&#10;&#10;    fun getPin(): String? = prefs.getString(KEY_PIN, null)&#10;    fun setPin(pin: String) = prefs.edit { putString(KEY_PIN, pin) }&#10;&#10;    fun getFailedAttempts(): Int = prefs.getInt(KEY_FAILED_ATTEMPTS, 0)&#10;    fun incrementFailedAttempts(): Int {&#10;        val next = getFailedAttempts() + 1&#10;        prefs.edit { putInt(KEY_FAILED_ATTEMPTS, next) }&#10;        return next&#10;    }&#10;&#10;    fun resetFailedAttempts() = prefs.edit { putInt(KEY_FAILED_ATTEMPTS, 0) }&#10;&#10;    fun getLockUntil(): Long = prefs.getLong(KEY_LOCK_UNTIL, 0L)&#10;    fun setLockUntil(untilMs: Long) = prefs.edit { putLong(KEY_LOCK_UNTIL, untilMs) }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>