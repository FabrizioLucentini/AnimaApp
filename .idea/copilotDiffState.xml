<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.anima&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.anima&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;    // Room (explicit coordinates)&#10;    implementation(&quot;androidx.room:room-runtime:2.8.3&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.8.3&quot;)&#10;    kapt(&quot;androidx.room:room-compiler:2.8.3&quot;)&#10;&#10;    // Lifecycle ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.9.4&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.0&quot;)&#10;&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.anima.app&quot;&#10;    compileSdk {&#10;        version = release(36)&#10;    }&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.anima.app&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;    // Room (explicit coordinates)&#10;    implementation(&quot;androidx.room:room-runtime:2.8.3&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.8.3&quot;)&#10;    kapt(&quot;androidx.room:room-compiler:2.8.3&quot;)&#10;&#10;    // Lifecycle ViewModel Compose&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.9.4&quot;)&#10;&#10;    // Navigation Compose&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.0&quot;)&#10;&#10;    // Biometric authentication&#10;    implementation(&quot;androidx.biometric:biometric:1.1.0&quot;)&#10;&#10;    // Encrypted SharedPreferences for secure PIN storage&#10;    implementation(&quot;androidx.security:security-crypto:1.0.0&quot;)&#10;&#10;    // Optional: WorkManager (in case we later want it instead of AlarmManager)&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.8.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;!-- Permission to receive boot completed so we can reschedule alarms --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;    &lt;!-- Permission to post notifications on Android 13+ --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;!-- Allow scheduling exact alarms on platforms that require it --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:exported=&quot;true&quot;&#10;            android:name=&quot;.LockActivity&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot; /&gt;&#10;&#10;        &lt;!-- Allow system to deliver AlarmManager broadcasts to this receiver --&gt;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.NotificationReceiver&quot; android:exported=&quot;true&quot; /&gt;&#10;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.BootReceiver&quot; android:exported=&quot;true&quot; android:permission=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;!-- Permission to receive boot completed so we can reschedule alarms --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;    &lt;!-- Permission to post notifications on Android 13+ --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;!-- Allow scheduling exact alarms on platforms that require it --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:exported=&quot;true&quot;&#10;            android:name=&quot;com.example.anima.LockActivity&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.anima.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Anima&quot; /&gt;&#10;&#10;        &lt;!-- NotificationReceiver is triggered by app-created PendingIntent; keep it non-exported for safety --&gt;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.NotificationReceiver&quot; android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver android:name=&quot;com.example.anima.util.BootReceiver&quot; android:exported=&quot;true&quot; android:permission=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.LOCKED_BOOT_COMPLETED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/AlarmHelper.kt" />
              <option name="originalContent" value="package com.example.anima.util&#10;&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.util.Calendar&#10;&#10;object AlarmHelper {&#10;    private const val REQUEST_CODE_REMINDER = 1001&#10;    private const val REQUEST_CODE_SHOW = 1002&#10;    private const val REQUEST_CODE_TEST = 1003&#10;&#10;    fun scheduleDailyReminder(context: Context, hour: Int, minute: Int, message: String) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val trigger = computeNextTriggerCalendar(hour, minute)&#10;&#10;            // debug log scheduled time&#10;            val scheduledStr = &quot;%04d-%02d-%02d %02d:%02d&quot;.format(&#10;                trigger.get(Calendar.YEAR),&#10;                trigger.get(Calendar.MONTH) + 1,&#10;                trigger.get(Calendar.DAY_OF_MONTH),&#10;                trigger.get(Calendar.HOUR_OF_DAY),&#10;                trigger.get(Calendar.MINUTE)&#10;            )&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling daily reminder for: $scheduledStr (epoch=${trigger.timeInMillis})&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                // Try to use setAlarmClock for more reliable exact delivery&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(trigger.timeInMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed, falling back to setExactAndAllowWhileIdle&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                // fallback&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    trigger.timeInMillis,&#10;                    pending&#10;                )&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            // verify the pending intent exists now&#10;            val exists = isReminderScheduled(context)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Reminder PendingIntent exists after schedule: $exists&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule daily reminder&quot;, t)&#10;            // swallow to avoid crashing UI flows&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule an alarm at a specific epoch millisecond time for quick testing.&#10;     * Returns true if scheduled without throwing.&#10;     */&#10;    fun scheduleAtMillis(context: Context, triggerMillis: Long, message: String): Boolean {&#10;        return try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_TEST,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val scheduledStr = java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(java.util.Date(triggerMillis))&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling test alarm for: $scheduledStr (epoch=$triggerMillis)&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(triggerMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed for test alarm, falling back&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerMillis, pending)&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule test alarm&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun cancelReminder(context: Context) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            alarmManager.cancel(pending)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Cancelled reminder (PendingIntent canceled)&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to cancel reminder&quot;, t)&#10;        }&#10;    }&#10;&#10;    fun isReminderScheduled(context: Context): Boolean {&#10;        return try {&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            pending != null&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Error checking reminder pending intent&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Compute and return the next trigger time in epoch millis for the given hour/minute&#10;    fun computeNextTriggerMillis(hour: Int, minute: Int): Long {&#10;        val cal = computeNextTriggerCalendar(hour, minute)&#10;        return cal.timeInMillis&#10;    }&#10;&#10;    private fun computeNextTriggerCalendar(hour: Int, minute: Int): Calendar {&#10;        val now = Calendar.getInstance()&#10;        val trigger = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, hour)&#10;            set(Calendar.MINUTE, minute)&#10;            set(Calendar.SECOND, 0)&#10;            set(Calendar.MILLISECOND, 0)&#10;            if (before(now)) {&#10;                add(Calendar.DAY_OF_YEAR, 1)&#10;            }&#10;        }&#10;        return trigger&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.app.AlarmManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.util.Calendar&#10;&#10;object AlarmHelper {&#10;    private const val REQUEST_CODE_REMINDER = 1001&#10;    private const val REQUEST_CODE_SHOW = 1002&#10;    private const val REQUEST_CODE_TEST = 1003&#10;&#10;    fun scheduleDailyReminder(context: Context, hour: Int, minute: Int, message: String) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val trigger = computeNextTriggerCalendar(hour, minute)&#10;&#10;            // debug log scheduled time&#10;            val scheduledStr = &quot;%04d-%02d-%02d %02d:%02d&quot;.format(&#10;                trigger.get(Calendar.YEAR),&#10;                trigger.get(Calendar.MONTH) + 1,&#10;                trigger.get(Calendar.DAY_OF_MONTH),&#10;                trigger.get(Calendar.HOUR_OF_DAY),&#10;                trigger.get(Calendar.MINUTE)&#10;            )&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling daily reminder for: $scheduledStr (epoch=${trigger.timeInMillis})&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                // Try to use setAlarmClock for more reliable exact delivery&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(trigger.timeInMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed, falling back to setExactAndAllowWhileIdle&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                // fallback&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    trigger.timeInMillis,&#10;                    pending&#10;                )&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            // verify the pending intent exists now&#10;            val exists = isReminderScheduled(context)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Reminder PendingIntent exists after schedule: $exists&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule daily reminder&quot;, t)&#10;            // swallow to avoid crashing UI flows&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule an alarm at a specific epoch millisecond time for quick testing.&#10;     * Returns true if scheduled without throwing.&#10;     */&#10;    fun scheduleAtMillis(context: Context, triggerMillis: Long, message: String): Boolean {&#10;        return try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java).apply {&#10;                putExtra(&quot;msg&quot;, message)&#10;            }&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_TEST,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;&#10;            val scheduledStr = java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(java.util.Date(triggerMillis))&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Scheduling test alarm for: $scheduledStr (epoch=$triggerMillis)&quot;)&#10;&#10;            var usedAlarmClock = false&#10;            try {&#10;                val showIntent = Intent(context, com.example.anima.MainActivity::class.java)&#10;                val showPending = PendingIntent.getActivity(&#10;                    context,&#10;                    REQUEST_CODE_SHOW,&#10;                    showIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                val info = AlarmManager.AlarmClockInfo(triggerMillis, showPending)&#10;                alarmManager.setAlarmClock(info, pending)&#10;                usedAlarmClock = true&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setAlarmClock for $scheduledStr&quot;)&#10;            } catch (t: Throwable) {&#10;                Log.w(&quot;AlarmHelper&quot;, &quot;setAlarmClock failed for test alarm, falling back&quot;, t)&#10;            }&#10;&#10;            if (!usedAlarmClock) {&#10;                alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerMillis, pending)&#10;                Log.d(&quot;AlarmHelper&quot;, &quot;Test alarm scheduled using setExactAndAllowWhileIdle for $scheduledStr&quot;)&#10;            }&#10;&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to schedule test alarm&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    fun cancelReminder(context: Context) {&#10;        try {&#10;            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            alarmManager.cancel(pending)&#10;            Log.d(&quot;AlarmHelper&quot;, &quot;Cancelled reminder (PendingIntent canceled)&quot;)&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Failed to cancel reminder&quot;, t)&#10;        }&#10;    }&#10;&#10;    fun isReminderScheduled(context: Context): Boolean {&#10;        return try {&#10;            val intent = Intent(context, com.example.anima.util.NotificationReceiver::class.java)&#10;            val pending = PendingIntent.getBroadcast(&#10;                context,&#10;                REQUEST_CODE_REMINDER,&#10;                intent,&#10;                PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE&#10;            )&#10;            pending != null&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;AlarmHelper&quot;, &quot;Error checking reminder pending intent&quot;, t)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Compute and return the next trigger time in epoch millis for the given hour/minute&#10;    fun computeNextTriggerMillis(hour: Int, minute: Int): Long {&#10;        val cal = computeNextTriggerCalendar(hour, minute)&#10;        return cal.timeInMillis&#10;    }&#10;&#10;    private fun computeNextTriggerCalendar(hour: Int, minute: Int): Calendar {&#10;        val now = Calendar.getInstance()&#10;        val trigger = Calendar.getInstance().apply {&#10;            set(Calendar.HOUR_OF_DAY, hour)&#10;            set(Calendar.MINUTE, minute)&#10;            set(Calendar.SECOND, 0)&#10;            set(Calendar.MILLISECOND, 0)&#10;            // If trigger is not strictly after 'now' (equal or before), schedule for next day&#10;            if (!after(now)) {&#10;                add(Calendar.DAY_OF_YEAR, 1)&#10;            }&#10;        }&#10;        return trigger&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/BootReceiver.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import com.example.anima.util.SecurePrefs&#10;import com.example.anima.util.AlarmHelper&#10;&#10;class BootReceiver : BroadcastReceiver() {&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        val action = intent?.action&#10;        if (action != Intent.ACTION_BOOT_COMPLETED &amp;&amp; action != Intent.ACTION_LOCKED_BOOT_COMPLETED) return&#10;        try {&#10;            val prefs = SecurePrefs(context)&#10;            if (prefs.isReminderEnabled()) {&#10;                AlarmHelper.scheduleDailyReminder(context, prefs.getReminderHour(), prefs.getReminderMinute(), prefs.getReminderMessage())&#10;            }&#10;        } catch (t: Throwable) {&#10;            // ignore errors on boot handling&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationHelper.kt" />
              <option name="originalContent" value="package com.example.anima.util&#10;&#10;import android.Manifest&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.core.content.ContextCompat&#10;&#10;object NotificationHelper {&#10;    private const val TEST_NOTIFY_ID = 2001&#10;&#10;    fun createChannelIfNeeded(context: Context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Recordatorios&quot;&#10;            val descriptionText = &quot;Canal para recordatorios diarios&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(NotificationReceiver.CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send a test notification. Returns true if notification was posted, false otherwise (e.g. no permission).&#10;     */&#10;    fun sendTestNotification(context: Context, msg: String): Boolean {&#10;        // On Android 13+ ensure POST_NOTIFICATIONS permission is granted&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;                Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted; not sending notification&quot;)&#10;                return false&#10;            }&#10;        }&#10;&#10;        createChannelIfNeeded(context)&#10;        return try {&#10;            val builder = NotificationCompat.Builder(context, NotificationReceiver.CHANNEL_ID)&#10;                .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;                .setContentTitle(&quot;Anima (Prueba)&quot;)&#10;                .setContentText(msg)&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;                .setAutoCancel(true)&#10;&#10;            NotificationManagerCompat.from(context).notify(TEST_NOTIFY_ID, builder.build())&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;NotificationHelper&quot;, &quot;Failed to post test notification&quot;, t)&#10;            false&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.Manifest&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.app.PendingIntent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import androidx.core.content.ContextCompat&#10;&#10;object NotificationHelper {&#10;    private const val TEST_NOTIFY_ID = 2001&#10;&#10;    fun createChannelIfNeeded(context: Context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Recordatorios&quot;&#10;            val descriptionText = &quot;Canal para recordatorios diarios&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(NotificationReceiver.CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send a test notification. Returns true if notification was posted, false otherwise (e.g. no permission).&#10;     */&#10;    fun sendTestNotification(context: Context, msg: String): Boolean {&#10;        // On Android 13+ ensure POST_NOTIFICATIONS permission is granted&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;                Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted; not sending notification&quot;)&#10;                return false&#10;            }&#10;        }&#10;&#10;        createChannelIfNeeded(context)&#10;        return try {&#10;            val builder = NotificationCompat.Builder(context, NotificationReceiver.CHANNEL_ID)&#10;                .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;                .setContentTitle(&quot;Anima (Prueba)&quot;)&#10;                .setContentText(msg)&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;                .setAutoCancel(true)&#10;&#10;            // Make notification clickable: open the app's launch activity&#10;            try {&#10;                val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;                if (launchIntent != null) {&#10;                    launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)&#10;                    val pending = PendingIntent.getActivity(&#10;                        context,&#10;                        0,&#10;                        launchIntent,&#10;                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                    )&#10;                    builder.setContentIntent(pending)&#10;                }&#10;            } catch (_: Throwable) {&#10;                // ignore; notification will still post without click action&#10;            }&#10;&#10;            NotificationManagerCompat.from(context).notify(TEST_NOTIFY_ID, builder.build())&#10;            true&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;NotificationHelper&quot;, &quot;Failed to post test notification&quot;, t)&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/anima/util/NotificationReceiver.kt" />
              <option name="originalContent" value="package com.example.anima.util&#10;&#10;import android.Manifest&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.content.ContextCompat&#10;import java.util.concurrent.Executors&#10;&#10;class NotificationReceiver : BroadcastReceiver() {&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;anima_reminder_channel&quot;&#10;        const val ACTION_REMIND = &quot;com.example.anima.action.REMIND&quot;&#10;    }&#10;&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        Log.d(&quot;NotificationReceiver&quot;, &quot;onReceive called, intent=${intent}&quot;)&#10;        val msg = intent?.getStringExtra(&quot;msg&quot;) ?: &quot;¿Cómo te sentís hoy?&quot;&#10;        createChannelIfNeeded(context)&#10;&#10;        // Record last fired timestamp for diagnostics&#10;        try {&#10;            val prefs = SecurePrefs(context)&#10;            prefs.setLastReminderFired(System.currentTimeMillis())&#10;        } catch (t: Throwable) {&#10;            Log.w(&quot;NotificationReceiver&quot;, &quot;Failed to record last fired timestamp&quot;, t)&#10;        }&#10;&#10;        // Optional visual confirmation for debugging (a short toast)&#10;        try {&#10;            Toast.makeText(context, &quot;Recordatorio: $msg&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (t: Throwable) {&#10;            // ignore to avoid crashing receiver&#10;            Log.w(&quot;NotificationReceiver&quot;, &quot;Failed to show toast in receiver&quot;, t)&#10;        }&#10;&#10;        // Check notification permission on Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                Log.w(&quot;NotificationReceiver&quot;, &quot;POST_NOTIFICATIONS not granted; skipping notify&quot;)&#10;                return&#10;            }&#10;        }&#10;&#10;        val builder = NotificationCompat.Builder(context, CHANNEL_ID)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentTitle(&quot;Anima&quot;)&#10;            .setContentText(msg)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;&#10;        try {&#10;            with(NotificationManagerCompat.from(context)) {&#10;                notify(1000, builder.build())&#10;                Log.d(&quot;NotificationReceiver&quot;, &quot;Notification posted (id=1000)&quot;)&#10;            }&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;NotificationReceiver&quot;, &quot;Failed to post notification&quot;, t)&#10;        }&#10;&#10;        // Schedule next day to keep it daily (because we used exact alarm for a single trigger)&#10;        // Read stored hour/minute and reschedule&#10;        Executors.newSingleThreadExecutor().execute {&#10;            try {&#10;                val prefs = SecurePrefs(context)&#10;                if (prefs.isReminderEnabled()) {&#10;                    val h = prefs.getReminderHour()&#10;                    val m = prefs.getReminderMinute()&#10;                    val message = prefs.getReminderMessage()&#10;                    Log.d(&quot;NotificationReceiver&quot;, &quot;Rescheduling next reminder for ${h}:${m}&quot;)&#10;                    AlarmHelper.scheduleDailyReminder(context, h, m, message)&#10;                }&#10;            } catch (t: Throwable) {&#10;                Log.e(&quot;NotificationReceiver&quot;, &quot;Error rescheduling reminder&quot;, t)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun createChannelIfNeeded(context: Context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Recordatorios&quot;&#10;            val descriptionText = &quot;Canal para recordatorios diarios&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;            Log.d(&quot;NotificationReceiver&quot;, &quot;Notification channel created/ensured: $CHANNEL_ID&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.anima.util&#10;&#10;import android.Manifest&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.content.ContextCompat&#10;import java.util.concurrent.Executors&#10;import android.app.PendingIntent&#10;&#10;class NotificationReceiver : BroadcastReceiver() {&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;anima_reminder_channel&quot;&#10;        const val ACTION_REMIND = &quot;com.example.anima.action.REMIND&quot;&#10;    }&#10;&#10;    override fun onReceive(context: Context, intent: Intent?) {&#10;        Log.d(&quot;NotificationReceiver&quot;, &quot;onReceive called, intent=${intent}&quot;)&#10;        val msg = intent?.getStringExtra(&quot;msg&quot;) ?: &quot;¿Cómo te sentís hoy?&quot;&#10;        createChannelIfNeeded(context)&#10;&#10;        // Record last fired timestamp for diagnostics&#10;        try {&#10;            val prefs = SecurePrefs(context)&#10;            prefs.setLastReminderFired(System.currentTimeMillis())&#10;        } catch (t: Throwable) {&#10;            Log.w(&quot;NotificationReceiver&quot;, &quot;Failed to record last fired timestamp&quot;, t)&#10;        }&#10;&#10;        // Optional visual confirmation for debugging (a short toast)&#10;        try {&#10;            Toast.makeText(context, &quot;Recordatorio: $msg&quot;, Toast.LENGTH_SHORT).show()&#10;        } catch (t: Throwable) {&#10;            // ignore to avoid crashing receiver&#10;            Log.w(&quot;NotificationReceiver&quot;, &quot;Failed to show toast in receiver&quot;, t)&#10;        }&#10;&#10;        // Check notification permission on Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                Log.w(&quot;NotificationReceiver&quot;, &quot;POST_NOTIFICATIONS not granted; skipping notify&quot;)&#10;                return&#10;            }&#10;        }&#10;&#10;        val builder = NotificationCompat.Builder(context, CHANNEL_ID)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentTitle(&quot;Anima&quot;)&#10;            .setContentText(msg)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setAutoCancel(true)&#10;&#10;        // Make notification clickable: open the app's launch activity when tapped&#10;        try {&#10;            val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)&#10;            if (launchIntent != null) {&#10;                launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)&#10;                val pending = PendingIntent.getActivity(&#10;                    context,&#10;                    0,&#10;                    launchIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;                builder.setContentIntent(pending)&#10;            }&#10;        } catch (t: Throwable) {&#10;            // ignore; notification will still post without click action&#10;        }&#10;&#10;        try {&#10;            with(NotificationManagerCompat.from(context)) {&#10;                notify(1000, builder.build())&#10;                Log.d(&quot;NotificationReceiver&quot;, &quot;Notification posted (id=1000)&quot;)&#10;            }&#10;        } catch (t: Throwable) {&#10;            Log.e(&quot;NotificationReceiver&quot;, &quot;Failed to post notification&quot;, t)&#10;        }&#10;&#10;        // Schedule next day to keep it daily (because we used exact alarm for a single trigger)&#10;        // Read stored hour/minute and reschedule&#10;        Executors.newSingleThreadExecutor().execute {&#10;            try {&#10;                val prefs = SecurePrefs(context)&#10;                if (prefs.isReminderEnabled()) {&#10;                    val h = prefs.getReminderHour()&#10;                    val m = prefs.getReminderMinute()&#10;                    val message = prefs.getReminderMessage()&#10;                    Log.d(&quot;NotificationReceiver&quot;, &quot;Rescheduling next reminder for ${h}:${m}&quot;)&#10;                    AlarmHelper.scheduleDailyReminder(context, h, m, message)&#10;                }&#10;            } catch (t: Throwable) {&#10;                Log.e(&quot;NotificationReceiver&quot;, &quot;Error rescheduling reminder&quot;, t)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun createChannelIfNeeded(context: Context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Recordatorios&quot;&#10;            val descriptionText = &quot;Canal para recordatorios diarios&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            val notificationManager: NotificationManager =&#10;                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;            Log.d(&quot;NotificationReceiver&quot;, &quot;Notification channel created/ensured: $CHANNEL_ID&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_launcher_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_launcher_background.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;108dp&quot;&#10;    android:height=&quot;108dp&quot;&#10;    android:viewportWidth=&quot;108&quot;&#10;    android:viewportHeight=&quot;108&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#3DDC84&quot;&#10;        android:pathData=&quot;M0,0h108v108h-108z&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M9,0L9,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,0L19,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M29,0L29,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M39,0L39,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M49,0L49,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M59,0L59,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M69,0L69,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M79,0L79,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M89,0L89,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M99,0L99,108&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,9L108,9&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,19L108,19&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,29L108,29&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,39L108,39&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,49L108,49&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,59L108,59&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,69L108,69&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,79L108,79&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,89L108,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M0,99L108,99&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,29L89,29&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,39L89,39&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,49L89,49&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,59L89,59&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,69L89,69&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M19,79L89,79&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M29,19L29,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M39,19L39,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M49,19L49,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M59,19L59,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M69,19L69,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#00000000&quot;&#10;        android:pathData=&quot;M79,19L79,89&quot;&#10;        android:strokeWidth=&quot;0.8&quot;&#10;        android:strokeColor=&quot;#33FFFFFF&quot; /&gt;&#10;&lt;/vector&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;!-- Simple solid background color for adaptive icon --&gt;&#10;    &lt;item&gt;&#10;        &lt;shape android:shape=&quot;rectangle&quot;&gt;&#10;            &lt;solid android:color=&quot;#6C5CE7&quot; /&gt;&#10;        &lt;/shape&gt;&#10;    &lt;/item&gt;&#10;&lt;/layer-list&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>